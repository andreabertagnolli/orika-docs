---
layout: post
id: advanced-mappings
title: Advanced Mapping Configurations
desc: beyond the basics of ClassMapBuilder API
---

h2. Customized ClassMapBuilder

In some cases, you may want to control the behavior of how the *byDefault()* method functions in aligning properties. The out-of-the-box behavior is to only match properties whose names are an exact match, but the behavior can be overridden by extending the basic ClassMapBuilder. 

A (functional) sample customization of ClassMapBuilder has been provided which uses a scoring method to automagically 'guess' the proper alignment of fields, based on the edit distance of the property names (and some other things); this class is *ma.glasnost.orika.metadata.ScoringClassMapBuilder*, and it can be registered on the DefaultMapperFactory.Builder like so:

<pre class="prettyprint">
MapperFactory factory = new DefaultMapperFactory.Builder()
    .classMapBuilderFactory(new ScoringClassMapBuilder.Factory())
    .build();
</pre>

_Review the code for this class to see how you could provide your own alternative_

h2. Ad-hoc/in-line property definitions

h4. Property expressions 

Most of the mapping details covered so far work fairly well to properties that conform to the JavaBeans standard; but what if your definition of "property" doesn't follow those rules? 

The built-in property resolver (which is used to parse the string values passed and line them up with the appropriate Property) has a special syntax available for defining properties on the fly, where you can override the getter, setter, name, and type to be used. As usual, the best way to explain is with an example...

Suppose we want to map from an object with a more generic structure, such as the _Element_ class shown below, which has getters and setters more like Map keys. 

<pre class="prettyprint left">
public static class Element {
    Map<String,Object> attributes = new HashMap<String,Object>();
    
    public Object getAttribute(String name) {
        return attributes.get(name);
    }
    public void setAttribute(String name, Object value) {
        attributes.put(name, value);
    }
}
</pre>

<pre class="prettyprint right">
public static class Person {
    public String firstName;
    public String lastName;
    public String jobTitle;
    public String salary;
}
</pre>
<br/>

We can define the properties of the Element type using in-line property definition, like so:

<pre class="prettyprint left">
"employment:{getAttribute('employment')|setAttribute('employment', %s)|type=ma.glasnost.orika.test.property.PropertyResolverTestCase.Element}";
</pre>

To break down the parts, we begin with the property name <code>employment</code>, follwed by <code>:{</code> to begin an *in-line property definition*.
We begin the in-line definition with the _getter_ first <code>getAttribute('employment')</code>, using the pipe <code>|</code> to separate it from the setter which follows: <code>setAttribute('employment', %s)</code>. Note the use of the <code>%s</code> place-holder, which represents the value to be set.
We follow this with another pipe <code>|</code> to separate the setter from the type definition). Note that the type definition  begins with *type=*.
Finally, we end the in-line definition with a closing brace <code>}</code>.

<div class="alert alert-info alert-block">
<h4 class="alert-heading">_In-line property syntax:_</h4>
<h3>&laquo;name&raquo; *:{* &laquo;getter&raquo;  *|* &laquo;setter&raquo; [ *|* *type=* &laquo;type&raquo; ] *}*</h3>
<h3>&laquo;name&raquo; *:{* &laquo;getter&raquo; [ *|* *type=* &laquo;type&raquo; ] *}*</h3>
<h3>&laquo;name&raquo; *:{|* &laquo;setter&raquo; [ *|* *type=* &laquo;type&raquo; ] *}*</h3>
</div>

So, to bring it together, we can define properties for these elements with the code snippet below. Note that we're defining some properties as nested (separated by the usual *'.'* as separator ).
Also note that we can refer to an inline property already defined simply by using it's name; no need to repeat the definition for each reference.

<pre class="prettyprint left">
String employmentDef = 
  "employment:{getAttribute('employment')|setAttribute('employment', %s)|type=ma.glasnost.orika.test.property.PropertyResolverTestCase.Element}";
String jobTitleDef = 
  "jobTitle:{getAttribute(\"job's Title\")|setAttribute(\"job's Title\", %s)|type=List<String>}";
String salaryDef = 
  "salary:{getAttribute(\"'salary'\")|setAttribute(\"'salary'\", %s)|type=java.lang.Long}";

String nameDef =
  "name:{getAttribute('name')|setAttribute('name',%s)|type=ma.glasnost.orika.test.property.PropertyResolverTestCase.Element}";
String firstNameDef = "first:{getAttribute('first')|setAttribute('first', %s)|type=java.lang.String}";
String lastNameDef = "last:{getAttribute('last')|setAttribute('last', %s)|type=java.lang.String}";

factory.classMap(Element.class, Person.class)
    .field(employmentDef + "." + jobTitleDef, "jobTitles")
    .field("employment." + salaryDef, "salary") // reuse the in-line declaration of 'employment' property
    .field(nameDef + "." + firstNameDef, "firstName")
    .field("name." + lastNameDef, "lastName") // reuses the in-line declaration of 'name' property
    .register();
</pre>

h4. Defining properties with Property.Builder

Properties can also be defined in a more programmatic way, using the _Property.Builder_ API, as seen in the following example:

<pre class="prettyprint">
Property.Builder.propertyFor(Element.class, "employment")
    .type(Element.class)
    .getter("getAttribute(\"employment\")")
    .setter("setAttribute(\"employment\", %s)");
</pre>

h2. Customizing the PropertyResolverStrategy

In case you have many properties of the same type (say, our _Element_ class), a custom PropertyResolverStrategy can be defined which automatically injects an inline definition matching our custom type in the case that the normal property lookup has failed. The definition is shown below:

<pre class="prettyprint">
public static class ElementPropertyResolver extends IntrospectorPropertyResolver {
  protected Property getProperty(java.lang.reflect.Type type, String expr, 
  		boolean isNestedLookup, Property owner) throws MappingException {
    Property property = null;
    try {
      property = super.getProperty(type, expr, isNestedLookup, null);
    } catch (MappingException e) {
      try {
        property = super.resolveInlineProperty(type, expr + 
            ":{getAttribute(\""+ expr+"\")|setAttribute(\""+ expr+"\",%s)|type=" + 
            (isNestedLookup ? Element.class.getName() : "Object") + "}");
      } catch (MappingException e2) {
        throw e; // throw the original exception
      }
    }
    return property;
  }
}

/*
 * Register this on the DefaultMapperFactory.Builder
 */
MapperFactory factory = new DefaultMapperFactory.Builder()
                    .propertyResolverStrategy(new ElementPropertyResolver())
                    .build();
</pre>
