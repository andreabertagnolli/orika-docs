---
layout: post
id: advanced-mappings
title: Advanced Mapping Configurations
desc: beyond the basics of ClassMapBuilder API
---

h2. Ad-hoc/in-line property definitions

Most of the mapping details covered so far work fairly well to properties that conform to the JavaBeans standard; but what if your definition of "property" doesn't follow those rules? 

The built-in property resolver (which is used to parse the string values passed and line them up with the appropriate Property) has a special syntax available for defining properties on the fly, where you can override the getter, setter, name, and type to be used. As usual, the best way to explain is with an example...

h2. 

A ClassMapBuilder is obtained by calling the *_(big)classMap(aType, bType)_* method on a MapperFactory instance. It's best to start with an example -- suppose we have some instances of class *BasicPerson* that we'd like to map to instances of another class *BasicPersonDto*, defined like so:

<pre class="prettyprint">
class BasicPerson {
  private String name;
  private int age;
  private Date birthDate;
  // getters/setters omitted
}
class BasicPersonDto { 
  private String fullName;
  private int currentAge;
  private Date birthDate;
  // getters/setters omitted
}
</pre>

In order to map between these classes, we'll need to first register a ClassMap for the two types, which is created like so:

<pre class="prettyprint">
  mapperFactory.classMap(BasicPerson.class, BasicPersonDto.class)
  	.field("name", "fullName")
  	.field("age", "currentAge")
  	.register();
</pre>

h4. Mapping fields by default

In the case where one or more fields in the two types being mapped have matching names, the *byDefault* method can be used, like so:

<pre class="prettyprint">
  mapperFactory.classMap(BasicPerson.class, BasicPersonDto.class)
  	.field("name", "fullName")
  	.field("age", "currentAge")
  	.byDefault()
  	.register();
</pre>


h4. Mapping fields in one direction only

By default, a field mapping added using the *field(nameA, nameB)* method is bi-directional. To declare a field mapping that is only used in a single direction, use one of the *fieldAToB* or *fieldBToA* methods, like so:

<pre class="prettyprint">
  mapperFactory.classMap(BasicPerson.class, BasicPersonDto.class)
  	.fieldAToB("name", "fullName")
  	...
  	.register();
</pre>

_This would result in the 'name' field of BasicPerson being copied to the 'fullName' field of BasicPersonDto, but does not include mapping 'fullName' to 'name' when mapping is in the other direction._


h4. Excluding a field from mapping

To explicitly exclude a field from mapping, use the *exclude(name)*, like so:

<pre class="prettyprint">
  mapperFactory.classMap(BasicPerson.class, BasicPersonDto.class)
  	.exclude("name")
  	...
  	.register();
</pre>

_This would exclude the 'name' field from mapping._

h4. Specifying a particular constructor to use

Orika will attempt to find a best-fit match when choosing which constructor to use for instantiating the mapped types. To explicitly specify that Orika should use one particular constructor, use the *constructorA(parameterNames...)* and *constructorB(parameterNames...)*, as shown below; the *constructorA* method is used to specify a constructor for the 'left' side of the mapping, and *constructorB* is used to specify a constructor for the 'right' side. 

In this example, we specify that the constructor with parameters { "name", "id" } should be used to instantiate instances of _BasicPerson_:

<pre class="prettyprint">
mapperFactory.classMap(BasicPerson.class, BasicPersonDto.class)
   .constructorA("name","id")
   ...
   .register();
</pre>

h4. Mapping of null values

h5. At the ClassMap level

Mapping of null values can be controlled on a ClassMapBuilder by using the *mapNulls(true|false)* or *mapNullsInReverse(true|false)* (for controlling mapping of nulls in the reverse direction). By setting this value on a ClassMapBuilder, all field mappings created on the same ClassMapBuilder (after the value is set) will take on that same value. For example:

<pre class="prettyprint">
mapperFactory.classMap(BasicPerson.class, BasicPersonDto.class)
   .mapNulls(true).mapNullsInReverse(true)
   .field("field1", "fieldOne")
   .mapNulls(false).mapNullsInReverse(false)
   .field("field2", "fieldTwo")
   .byDefault()
   .register();
</pre>

Let's break down this example; first, we set _mapNulls(true)_ and _mapNullsInReverse(true)_, which specifies that the field 'fieldOne' will be set to *null* if 'field1' is null (mapNulls(true)), and also that the field 'field1' will be set to *null* if 'fieldOne' is null (mapNullsInReverse(true)) -- this is because this field mapping statement followed the original setting.

Next, we set mapNulls(false) and mapNullsInReverse(false), which means that all of the field mapping statements following it will not map null values.

h5. At the FieldMap level

Note that we can also set this value individually on specific field maps, as in the following example:

<pre class="prettyprint">
mapperFactory.classMap(BasicPerson.class, BasicPersonDto.class)
   .mapNulls(false).mapNullsInReverse(false)
   .fieldMap("field1", "fieldOne").mapNulls(true).mapNullsInReverse(true).add()
   .field("field2", "fieldTwo")
   .byDefault()
   .register();
</pre>

In this example, we've set the default for this ClassMap to _not_ map nulls (in either direction), but for the mapping of 'field1' to 'fieldOne' (in both directions), we specified that null values _should_ be mapped.

h4. Mapping elements of Arrays and Lists

Field names can refer specific elements of arrays and lists, by using the typical syntax for referencing array and list elements used by Java EL, for example, suppose we have the class structure given below:

<pre class="prettyprint">
class BasicPerson {
  private List<String> nameParts;
  // getters/setters omitted
}
class BasicPersonDto { 
  private String firstName;
  private String lastName;
  // getters/setters omitted
}
</pre>

We could map the first element of BasicPerson's 'nameParts' to BasicPersonDto's 'firstName' property, and the second element to 'lastName', like so:
 
<pre class="prettyprint">
mapperFactory.classMap(BasicPerson.class, BasicPersonDto.class)
   .field("nameParts[0]", "firstName")
   .field("nameParts[1]", "lastName")
   .register();
</pre>

_Note that the same structure would work if 'nameParts' were defined as a `String[]`_

h4. Mapping values of Map properties

The same pattern may be applied to refer to values in a Map by listing the key's value within brackets, but the key value should be quoted (double or single); assuming that the 'nameParts' property from the previous example were defined as a `Map<String, String>`, we could reference individual key values like so:

<pre class="prettyprint">
mapperFactory.classMap(BasicPerson.class, BasicPersonDto.class)
   .field("nameParts['first']", "firstName")
   .field("nameParts[\"last\"]", "lastName")
   .register();
</pre>

h4. Mapping nested fields

Nested properties may be referenced using standard dot '.' notation to separate properites, for example, assume we have the class structure listed below:

<pre class="prettyprint">
class Name {
   private String first;
   private String last;
   private String fullName;
   // getters/setters 
}

class BasicPerson {
  private Name name;
  // getters/setters omitted
}
class BasicPersonDto { 
  private String firstName;
  // getters/setters omitted
}
</pre>

Then the following syntax could be used to map the nested "first" property of BasicPerson's "name" to the "firstName" property of BasicPersonDto:

<pre class="prettyprint">
mapperFactory.classMap(BasicPerson.class, BasicPersonDto.class)
   .field("name.first", "firstName")
   .register();
</pre>

h4. Mapping nested multi-occurrence elements

Nested multi-occurrence elements (of Array, Collection or Map) can also be mapped, by using syntax similar to that used for referencing individual indicies of Arrays, Lists or Maps. Suppose we have the class structure given below:

<pre class="prettyprint">
class Person {
   private List<Name> names;
   // getters/setters 
}

class PersonDto { 
  private Map<String, Name> names;
  private String[] firstNames;
  private List<String> lastNames;
  // getters/setters omitted
}

</pre>
If we wanted to map the 'names' property from Person into the Map 'names' in PersonDto, with the 'fullName' property as the key, and the Name element as the value, we could accomplish it with the following syntax:

<pre class="prettyprint">
mapperFactory.classMap(Person.class, PersonDto.class)
   .field("names{fullName}", "names{key}")
   .field("names{}", "names{value}")
   .register();
</pre>
  
A few things to note: 
* the element of a Map is assumed to be of type Map.Entry, so we can refer to either the 'key' or 'value' property of this element.
* nested properties are legal within the brackets, and so are nested _element_ references, in case the element type itself also contains multi-occurrence fields that you want to map.  
* the empty field name within the brackets ("names[]") is used to refer to the element itself (rather than some property of the element)
